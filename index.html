<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>üçé Obst Obsession üçá</title>
<style>
  /* Grund-Reset & Body */
  body {
    font-family: Arial, sans-serif;
    text-align: center;
    margin: 0; padding: 0 0 2rem 0;
    background: #fafafa;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }
  h1 {
    margin: 1rem 0;
    font-weight: 900;
    font-size: 1.8rem;
  }

  /* Spielfeld Tabelle */
  #board {
    border-collapse: collapse;
    margin: 0 auto 1.5rem auto;
    width: 90vmin;
    height: 90vmin;
    max-width: 90vmin;
    max-height: 90vmin;
    aspect-ratio: 1 / 1;
    user-select: none;
  }
  #board td {
    border: 2px solid #555;
    font-size: 4vmin;
    text-align: center;
    vertical-align: middle;
    cursor: pointer;
    background: #eee;
    user-select: none;
    width: 12.5%;
    height: 12.5%;
    max-width: 60px;
    max-height: 60px;
    line-height: 1;
  }
  #board td {
  border: 2px solid #555;
}
  /* Vorgaben */
  #board td.prefilled {
    background: #cce5ff;
    cursor: default;
  }
  /* Editierbare Zellen haben Zeigefinger-Cursor */
  #board td.editable {
    cursor: pointer;
  }

  /* Buttons */
  button {
    font-size: 1rem;
    padding: 0.4rem 1.2rem;
    margin: 0 0.5rem;
    border-radius: 10px;
    border: none;
    cursor: pointer;
    user-select: none;
  }
  button:focus {
    outline: 2px solid #007bff;
  }
  #checkBtn {
    background-color: #4CAF50;
    color: white;
  }
  #newBtn {
    background-color: #87ceeb;
    color: black;
  }

  /* Keine Markierung erlauben auf Safari auch f√ºr Bilder */
  #board td img {
    -webkit-user-drag: none;
    user-drag: none;
    pointer-events: none;
  }

  /* Responsive Text und Layout */
  @media (max-width: 600px) {
    h1 {
      font-size: 1.4rem;
    }
    #board td {
      font-size: 6vw;
      max-width: none;
      max-height: none;
    }
    button {
      font-size: 1.1rem;
      padding: 0.6rem 1.4rem;
    }
  }
</style>
</head>
<body>
<h1>üçé Obst Obsession üçá</h1>
<table id="board" role="grid" aria-label="Obst Obsession Spielfeld" aria-live="polite"></table>
<div>
  <button id="checkBtn" aria-label="L√∂sung pr√ºfen">‚úÖ L√∂sung pr√ºfen</button>
  <button id="newBtn" aria-label="Neues Spiel starten">üîÑ Neues Spiel</button>
</div>

<script>
(() => {
  const size = 8; // 8x8 Raster
  const fruits = ["", "üçé", "üçå", "üçà", "üçá"]; // "" = leer, dann 4 Fr√ºchte
  const fruitCount = fruits.length - 1;
  const maxPrefilled = 25;

  let board = []; // 2D Array 8x8 mit Zahlen 0-4
  let prefilled = []; // 2D Array bool ob vorgegeben

  const boardEl = document.getElementById("board");
  const checkBtn = document.getElementById("checkBtn");
  const newBtn = document.getElementById("newBtn");

  // Hilfsfunktion: Erzeuge leeres Array
  function make2DArray(val = 0) {
    return Array.from({length: size}, () => Array(size).fill(val));
  }

  // Anzeigen des Boards
  function renderBoard() {
    boardEl.innerHTML = "";
    for (let r = 0; r < size; r++) {
      const tr = document.createElement("tr");
      for (let c = 0; c < size; c++) {
        const td = document.createElement("td");
        td.setAttribute("role", "gridcell");
        td.setAttribute("tabindex", prefilled[r][c] ? "-1" : "0");
        td.dataset.r = r;
        td.dataset.c = c;
        const val = board[r][c];
        td.textContent = fruits[val];
        if (prefilled[r][c]) {
          td.classList.add("prefilled");
          td.setAttribute("aria-readonly", "true");
        } else {
          td.classList.add("editable");
          td.setAttribute("aria-label", "Leeres Feld, tippen zum √§ndern");
        }
        tr.appendChild(td);
      }
      boardEl.appendChild(tr);
    }
  }

  // Pr√ºfen ob g√ºltig: Keine doppelten Fr√ºchte in Reihe & Spalte & Box (2x2)
  function isValidBoard(bd) {
    // Check Reihen & Spalten
    for(let i=0; i<size; i++) {
      const rowFruits = new Set();
      const colFruits = new Set();
      for(let j=0; j<size; j++) {
        let rVal = bd[i][j];
        if(rVal !== 0) {
          if(rowFruits.has(rVal)) return false;
          rowFruits.add(rVal);
        }
        let cVal = bd[j][i];
        if(cVal !== 0) {
          if(colFruits.has(cVal)) return false;
          colFruits.add(cVal);
        }
      }
    }
    // Check 2x2 Boxen
    for(let boxR=0; boxR<size; boxR+=2) {
      for(let boxC=0; boxC<size; boxC+=2) {
        const boxSet = new Set();
        for(let r=boxR; r<boxR+2; r++) {
          for(let c=boxC; c<boxC+2; c++) {
            const val = bd[r][c];
            if(val !== 0) {
              if(boxSet.has(val)) return false;
              boxSet.add(val);
            }
          }
        }
      }
    }
    return true;
  }

  // Backtracking: L√∂se Board (zur eindeutigen L√∂sung pr√ºfen)
  // Z√§hlt L√∂sungen und bricht ab wenn >1 gefunden
  function solveBoard(bd, limit = 2) {
    let solutions = 0;

    function backtrack(r=0,c=0) {
      if (r === size) {
        solutions++;
        return solutions >= limit;
      }
      let nr = r, nc = c+1;
      if (nc === size) { nr++; nc=0; }
      if (bd[r][c] !== 0) return backtrack(nr,nc);
      for (let f=1; f<=fruitCount; f++) {
        bd[r][c] = f;
        if(isValidBoard(bd)) {
          if(backtrack(nr,nc)) return true;
        }
        bd[r][c] = 0;
      }
      return false;
    }

    backtrack();
    return solutions;
  }

  // Generiere neue L√∂sung (vollst√§ndige L√∂sung)
  function generateSolution() {
    let bd = make2DArray(0);
    function backtrack(r=0,c=0) {
      if (r === size) return true;
      let nr = r, nc = c+1;
      if (nc === size) { nr++; nc=0; }
      const fruitsShuffled = shuffleArray([...Array(fruitCount).keys()].map(i => i+1));
      for (const f of fruitsShuffled) {
        bd[r][c] = f;
        if (isValidBoard(bd)) {
          if(backtrack(nr,nc)) return true;
        }
        bd[r][c] = 0;
      }
      return false;
    }
    backtrack();
    return bd;
  }

  // Shuffle Hilfsfunktion
  function shuffleArray(arr) {
    for(let i=arr.length-1; i>0; i--) {
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]] = [arr[j],arr[i]];
    }
    return arr;
  }

  // Generiere Puzzle mit Vorgaben, garantiert eindeutige L√∂sung
  function generatePuzzle() {
    while(true) {
      const solution = generateSolution();
      // Erstelle Kopie, entferne zuf√§llig Zellen bis nur maxPrefilled bleiben
      let puzzle = solution.map(r => r.slice());
      // Erzeuge Liste aller Zellen
      let cells = [];
      for(let r=0;r<size;r++) {
        for(let c=0;c<size;c++) cells.push([r,c]);
      }
      cells = shuffleArray(cells);
      // Entferne Zellen zuf√§llig, bis nur maxPrefilled √ºbrig
      const toRemove = size*size - maxPrefilled;
      for(let i=0; i<toRemove; i++) {
        const [r,c] = cells[i];
        puzzle[r][c] = 0;
      }
      // Pr√ºfe eindeutige L√∂sung mit Backtracking
      if (solveBoard(puzzle, 2) === 1) {
        return {puzzle, solution};
      }
      // sonst nochmal neu probieren
    }
  }

  // Event Handler f√ºr Klick auf Zelle (nur editable)
  function onCellClick(e) {
    const td = e.target;
    if (!td.classList.contains("editable")) return;
    const r = +td.dataset.r;
    const c = +td.dataset.c;
    // Rotieren durch 0..4 (leer + 4 Fr√ºchte)
    let val = board[r][c];
    val++;
    if(val > fruitCount) val = 0;
    board[r][c] = val;
    td.textContent = fruits[val];
  }

  // Pr√ºfe L√∂sung - alle Regeln + keine leeren Zellen
  function checkSolution() {
    // Pr√ºfe keine leeren Zellen
    for(let r=0;r<size;r++) {
      for(let c=0;c<size;c++) {
        if(board[r][c] === 0) {
          alert("Bitte alle Felder ausf√ºllen (oder mit Obst belegen).");
          return false;
        }
      }
    }
    if(isValidBoard(board)) {
      alert("üéâ Herzlichen Gl√ºckwunsch! Die L√∂sung ist korrekt.");
      return true;
    } else {
      alert("‚ùå Falsch gemach üò≠.");
      return false;
    }
  }

  // Initialisierung
  function init() {
    const {puzzle, solution} = generatePuzzle();
    board = puzzle.map(r => r.slice());
    prefilled = puzzle.map(row => row.map(val => val !== 0));
    renderBoard();
  }

  // Listener
  boardEl.addEventListener("click", onCellClick);
  checkBtn.addEventListener("click", checkSolution);
  newBtn.addEventListener("click", init);

  // Starte erstes Spiel
  init();
})();
</script>
</body>
</html>
