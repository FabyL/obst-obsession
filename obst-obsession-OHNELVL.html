<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>ğŸ Obst Obsession mit Proof Solver</title>
  <style>
    body { font-family: sans-serif; text-align: center; background: #f0f0f0; padding: 20px; }
    h1 { margin-bottom: 10px; }
    table { border-collapse: collapse; margin: 20px auto; }
    td { width: 60px; height: 60px; border: 1px solid #333; text-align: center; vertical-align: middle; font-size: 32px; cursor: pointer; transition: background 0.3s; }
    .fixed { background: #d0eaff; cursor: default; }
    button { margin: 10px; padding: 10px 20px; font-size: 16px; }
    #victory { position: fixed; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.7); color:#fff; font-size: 48px; display: flex; align-items: center; justify-content: center; z-index: 10; opacity: 0; pointer-events: none; transition: opacity 0.5s; }
    #victory.show { opacity: 1; pointer-events: all; }
  </style>
</head>
<body>

<h1>ğŸ Obst Obsession ğŸ‡</h1>
<table id="grid"></table>
<button onclick="checkSolution()">âœ… LÃ¶sung prÃ¼fen</button>
<button onclick="resetGame()">ğŸ”„ Neues Spiel</button>
<button onclick="proofTest()">ğŸ§  Proof-Test starten</button>
<div id="victory">ğŸ‰ Du hast gewonnen! ğŸ‰</div>

<script>
const fruits = ["", "ğŸ", "ğŸŒ", "ğŸˆ", "ğŸ‡"];
let fixedCells = {};

function createGrid() {
  const table = document.getElementById("grid");
  table.innerHTML = "";
  for (let r = 0; r < 8; r++) {
    const row = table.insertRow();
    for (let c = 0; c < 8; c++) {
      const cell = row.insertCell();
      const key = `${r},${c}`;
      if (fixedCells[key]) {
        cell.textContent = fixedCells[key];
        cell.className = 'fixed';
      } else {
        cell.onclick = () => {
          let current = fruits.indexOf(cell.textContent);
          cell.textContent = fruits[(current + 1) % fruits.length];
        };
      }
    }
  }
}

function checkSolution() {
  const table = document.getElementById("grid");
  let valid = true;
  for (let i = 0; i < 8; i++) {
    let rowCounts = {}, colCounts = {};
    for (let j = 0; j < 8; j++) {
      const rowFruit = table.rows[i].cells[j].textContent;
      const colFruit = table.rows[j].cells[i].textContent;
      rowCounts[rowFruit] = (rowCounts[rowFruit] || 0) + 1;
      colCounts[colFruit] = (colCounts[colFruit] || 0) + 1;
      if (j < 7) {
        if (rowFruit !== "" && rowFruit === table.rows[i].cells[j+1].textContent) valid = false;
        if (colFruit !== "" && colFruit === table.rows[j+1].cells[i].textContent) valid = false;
      }
    }
    for (let fruit of fruits.slice(1)) {
      if (rowCounts[fruit] !== 2 || colCounts[fruit] !== 2) valid = false;
    }
  }
  if (valid) {
    document.getElementById("victory").classList.add("show");
    setTimeout(() => document.getElementById("victory").classList.remove("show"), 3000);
  } else {
    alert("âŒ Noch Fehler drin!");
  }
}

function generateSolvablePuzzle() {
  let attempts = 0;
  while (true) {
    fixedCells = {};
    attempts++;
    placeRandomStartFields();
    let grid = Array.from({ length: 8 }, () => Array(8).fill(""));
    for (let key in fixedCells) {
      const [r, c] = key.split(",").map(Number);
      grid[r][c] = fixedCells[key];
    }
    if (solve(grid)) break;
  }
}

function placeRandomStartFields() {
  let placed = 0, difficulty = 25;
  let grid = Array.from({ length: 8 }, () => Array(8).fill(""));
  while (placed < difficulty) {
    let r = Math.floor(Math.random() * 8);
    let c = Math.floor(Math.random() * 8);
    let key = `${r},${c}`;
    if (fixedCells[key]) continue;
    let possibleFruits = fruits.slice(1).filter(fruit => {
      if ((r>0 && grid[r-1][c] === fruit) || (r<7 && grid[r+1][c] === fruit) || (c>0 && grid[r][c-1] === fruit) || (c<7 && grid[r][c+1] === fruit)) return false;
      let rowCount = grid[r].filter(f => f === fruit).length;
      let colCount = grid.map(row => row[c]).filter(f => f === fruit).length;
      if (rowCount >= 2 || colCount >= 2) return false;
      return true;
    });
    if (possibleFruits.length === 0) continue;
    let fruit = possibleFruits[Math.floor(Math.random() * possibleFruits.length)];
    fixedCells[key] = fruit;
    grid[r][c] = fruit;
    placed++;
  }
}

function solve(grid) {
  function isValid(r,c,fruit) {
    let rowCount = grid[r].filter(f => f===fruit).length;
    let colCount = grid.map(row => row[c]).filter(f=>f===fruit).length;
    if (rowCount >=2 || colCount >=2) return false;
    if (r>0 && grid[r-1][c]===fruit) return false;
    if (r<7 && grid[r+1][c]===fruit) return false;
    if (c>0 && grid[r][c-1]===fruit) return false;
    if (c<7 && grid[r][c+1]===fruit) return false;
    return true;
  }
  function backtrack(r,c){
    if (c===8){c=0;r++;if(r===8)return true;}
    if(grid[r][c]!=="")return backtrack(r,c+1);
    for (let fruit of fruits.slice(1)){
      if(isValid(r,c,fruit)){
        grid[r][c]=fruit;
        if(backtrack(r,c+1)) return true;
        grid[r][c]="";
      }
    }
    return false;
  }
  return backtrack(0,0);
}

function proofTest() {
  let grid = Array.from({ length: 8 }, () => Array(8).fill(""));
  for (let key in fixedCells) {
    const [r, c] = key.split(",").map(Number);
    grid[r][c] = fixedCells[key];
  }
  let changed;
  do {
    changed = false;
    for (let r=0; r<8; r++) {
      for (let c=0; c<8; c++) {
        if (grid[r][c] !== "") continue;
        let options = fruits.slice(1).filter(fruit => {
          let rowCount = grid[r].filter(f => f===fruit).length;
          let colCount = grid.map(row => row[c]).filter(f=>f===fruit).length;
          if (rowCount >=2 || colCount >=2) return false;
          if (r>0 && grid[r-1][c]===fruit) return false;
          if (r<7 && grid[r+1][c]===fruit) return false;
          if (c>0 && grid[r][c-1]===fruit) return false;
          if (c<7 && grid[r][c+1]===fruit) return false;
          return true;
        });
        if (options.length === 1) {
          grid[r][c] = options[0];
          changed = true;
        }
      }
    }
  } while (changed);

  let filled = grid.flat().filter(f=>f!=="").length;
  if (filled === 64) alert("âœ… Logisch vollstÃ¤ndig lÃ¶sbar!");
  else alert("âš ï¸ Proof-Check: LÃ¤sst sich nicht komplett ohne Raten lÃ¶sen.");
}

function resetGame(){
  generateSolvablePuzzle();
  createGrid();
}

resetGame();
</script>

</body>
</html>
